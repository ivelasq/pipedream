{
  "hash": "13fde725ba5974c483b734724307e21e",
  "result": {
    "markdown": "---\ntitle: \"Taking a peek into my hiking data\"\ncategories: [\"import\", \"visualize\", \"analyze\"]\ndate: \"2019-04-06\"\ndescription: \"I got my hands on a bunch of GPX files.\"\nimage: thumbnail.jpg\n---\n\n![Thomas Moran, Winter in the Rockies (1867)](thumbnail-wide.jpg){fig-alt=\"A horizon of snow-capped mountains\"}\n\n\n\nI moved to Seattle at the end of 2016 and since then have done over 100 hikes (depending on your definition of 'a  hike'). I must admit I've been abysmal at tracking any data regarding my hiking activity beyond a [Google spreadsheet](https://docs.google.com/spreadsheets/d/1Y3NdGea6yVuoDS7ewUKmuKGZouzU62FHK-aY813TafA/edit?usp=sharing), despite the ubiquity of trail tracking apps that exist.\n\nRecently, I signed up on [AllTrails](https://www.alltrails.com/) to start collecting data on my hikes. The Pro service offers many wonderful features, including the ability to download GPX data on hikes. I was so excited by this that I decided to try to visualize the hikes I have done.\n\nI ran [a poll on Twitter](https://twitter.com/ivelasq3/status/1121536896956428289) in which I asked whether people embed code in the main text of their blog post or at the end. 91% embed in the main text [n = 85]. I structured this post accordingly.\n\n## Pulling data\n\n### Choose packages\n\nIt took a bit to decide which packages had the functions needed to run the spatial analyses. In the end, I decided on:\n\n* **plotKML**: A package containing functions to read GPX files.\n* **geosphere**: A package containing functions for geospatial calculations. I decided to use this for finding out distances between lon/lat.\n* **googleway**: A package allowing access to the Google Maps API. To run this, you need to obtain a Google Maps API key and load it to R by using `set_key()`. I use this for elevation calculations but the API can also obtain the distance between points.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(googleway)\nlibrary(plotKML)\nlibrary(geosphere)\n\ngoogleway::set_key(API_KEY_HERE)\n```\n:::\n\n### Tidy data\n\nI downloaded each GPX file from AllTrails and saved them in a file in my project organization. Their file names were TRAILNAME.gpx.\n\n* Using `plotKML::readGPX()` results in the files being loaded as lists.\n* I used `purrr` in conjunction with `plotKML()` to handily read them in and add the file name to the list. \n\n::: {.cell}\n\n```{.r .cell-code}\n# find gpx files\ndata_path <- \n  here::here(\"data\", \"raw\", \"gpx_files\")\n\nfiles <-\n  dir(data_path, pattern = \"*.gpx\", full.names = TRUE)\n\n# get trail names\nnames <-\n  dir(data_path, pattern = \"*.gpx\", full.names = FALSE) %>% \n  str_extract(\".+?(?=.gpx)\")\n\n# read all gpx files\ngpx_dat <-\n  map2(files,\n       names,\n       ~ readGPX(.x,\n         metadata = TRUE,\n         bounds = TRUE,\n         waypoints = TRUE,\n         tracks = TRUE,\n         routes = TRUE) %>%\n         list_modify(trail = .y)) # otherwise you can't tell which entry is for which trail\n```\n:::\n\n### Calculate elevation\n\nWe can use `googleway::google_elevation()` to access the Google Elevation API and calculate elevation for every lon/lat pair from the GPX files. Unfortunately, the API accepts and returns only a few requests at a time (~200 rows for these files). We have over 51,000 rows of data. So, we can create groups for every 200 rows and use a loop to make a call for each \n\nThis results in a list, so we can then create a tibble pulling out the data we want.\n\n::: {.cell}\n\n```{.r .cell-code}\nlonlat_dat <-\n  gpx_dat %>%\n  map_df(., ~.x$\"routes\"[[1]], .id = \"trail\") %>%\n  select(trail, lon, lat) %>% \n  group_by(trail) %>% \n  ungroup() %>% \n  mutate(group_number = (1:nrow(.) %/% 200) + 1) # https://stackoverflow.com/questions/32078578/how-to-group-by-every-7-rows-and-aggregate-those-7-values-by-median\n\ndat_lapply <- lapply(1:max(lonlat_dat$group_number), function(x) {\n  Sys.sleep(3)\n  \n  lonlat_dat %>%\n    filter(group_number == x) %>% # added a filter so you only pull a subset of the data.\n    do(elev_dat =\n         data.frame(\n           google_elevation(\n             df_locations = dplyr::select(., lon, lat),\n             location_type = \"individual\",\n             simplify = TRUE)))\n  })\n\ndat_lapply_elev_dat <-\n  dat_lapply %>%\n  map(., ~ .x$\"elev_dat\"[[1]])\n\nelev_df <-\n  dat_lapply_elev_dat %>% {\n    tibble(\n      elevation = map(., ~ .x$\"results.elevation\"),\n      lon = map(., ~ .x$\"results.location\"[[\"lng\"]]),\n      lat = map(.,  ~ .x$\"results.location\"[[\"lat\"]])\n    )\n  } %>% \n  unnest(.id = \"group_number\") %>% \n  select(group_number, elevation, lon, lat)\n```\n:::\n\n### Calculate distance\n\nNow we have a list of trails, longitudes and latitudes along their paths, and the elevation for each of those points. Now we want to calculate the distance along the paths.\n\n* We bring back `lonlat_dat` so we know what trails with which each point are associated.\n* To use calculate distance, we can use `distHaversine()` with two sets of lon/lat. We create the second set of lon/lat by creating a new variable that takes the \"next\" value in a vector (so we're calculating the distance between point A and point B, point B to point C, and so on).\n* `cumsum()` accumulates the distances between each set of lon/lat.\n* Finally, we calculate the elevation gain for each hike.\n\n::: {.cell}\n\n```{.r .cell-code}\nhiking_dat <-\n  plyr::join(elev_df, lonlat_dat, type = \"left\", match = \"first\") %>% \n  group_by(trail) %>% \n  mutate(elev_feet = elevation * 3.281, # to convert to feet\n         lon2 = lead(lon, 1),\n         lat2 = lead(lat, 1)) %>%\n  ungroup() %>% \n  mutate(dist = distHaversine(hiking_dat[, 2:3], hiking_dat[, 7:8])/1609.344) %>% # to convert to miles\n  group_by(trail) %>% \n  mutate(cumdist = cumsum(dist),\n         elev_gain = elev_feet - first(elev_feet)) %>%\n  ungroup()\n```\n:::\n\n### Create additional tables\n\nFor nerdy kicks, I also wanted to find out my 'average' hike - that is, the average distance, the average elevation, and the average elevation for each distance. I also wanted to see the total distance and elevation for each trail for which I pulled data.\n\n::: {.cell}\n\n```{.r .cell-code}\navg_elev <- # average elevation by distance\n  hiking_dat %>% \n  group_by(round(cumdist, 1)) %>% \n  summarize(mean(elev_gain))\n\nhiking_dat_by_trail <- # total gain/distance by trail\n  hiking_dat %>% \n  select(trail, cumdist, elev_gain) %>% \n  group_by(trail) %>%\n  summarize(tot_dist = max(cumdist, na.rm = T),\n            tot_elev_gain = max(elev_gain)) %>% \n  mutate(tot_dist_scaled = scale(tot_dist), # for cluster analysis\n         tot_elev_scaled = scale(tot_elev_gain))\n```\n:::\n\n## Creating visualizations\n\n## Disclaimer \n\nFor data collection, I downloaded each trail's GPX files from AllTrails. Because these data are proprietary, I will not be providing them. Some things to note:\n\n* Because these are data pulled from the website, they are not indicative of my actual hiking path (for example, Franklin Falls is a 2-mile hike in the summer, but in the winter is a 6-mile snowshoe).\n* There are hikes that I did back-to-back that I'd consider one hike but the trails might be listed separately on the site. For example, Deception Pass is actually made up of three small loops.\n\n## The hikes are wide and varied\n\nBeing fortunate enough to live near multiple mountain ranges, the hikes come in all shapes and sizes.\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_density_ridges(data = na.omit(hiking_dat),\n                      aes(x = cumdist,\n                          y = trail,\n                          group = trail),\n                      fill = \"#00204c\",\n                      rel_min_height = 0.01\n                      ) +\n  theme_minimal() +\n  theme(legend.position = \"none\")\n```\n:::\n\n![](joyplot.png){fig-alt=\"Joyplot showing trail distance and height\"}\n\n\nI calculated my 'average hike' - that is, the average elevation given the cumulative distance traveled.\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_ridgeline(data = hiking_dat,\n                 aes(x = cumdist,\n                     y = trail,\n                     group = trail,\n                     height = elev_gain),\n                 color = \"#c9b869\",\n                 alpha = 0) +\n  geom_line(data = avg_elev,\n            aes(x = `round(cumdist, 1)`,\n                y = `mean(elev_gain)`),\n            color = \"#00204c\",\n            size = 2) +\n  scale_x_continuous(name = \"Cumulative Distance (miles)\") +\n  scale_y_continuous(name = \"Cumulative Elevation (ft)\", limits = c(0, 5000)) +\n  theme_minimal() +\n  theme(legend.position = \"none\")\n```\n:::\n\n![](avg_hike.png){fig-alt=\"Line chart showing distance and elevation of individual hikes with a darker line highlighting the average elevation by distance\"}\n\n## Aggregated Data by Trail\n  \nIn the aggregate, there seems to be  a correlation (r^2 = 0.48) between total distance and total elevation.\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_point(data = hiking_dat_by_trail,\n             aes(x = tot_dist,\n                 y = tot_elev_gain,\n                 color = tot_elev_gain,\n                 size = tot_dist)) +\n  scale_x_continuous(name = \"Total Distance (miles)\") +\n  scale_y_continuous(name = \"Total Elevation (ft)\") +\n  scale_color_viridis(option = \"cividis\") +\n  theme_minimal() +\n  theme(legend.position = \"none\")\n```\n:::\n\n  \n![](tot_dis_elev.png){fig-alt=\"Scatterplot of total distance by total elevation\"}\n\n## There exist \"clusters\" of hikes\n\nI ran a quick [cluster analysis](https://uc-r.github.io/kmeans_clustering) to see if I can categorize my hikes in any way. Code is in the [Methodology](#methodology) section. Four clusters seemed to be optimal. I have dubbed them:\n\n* Cluster 1: \"Let's Get This Over With\" (steep & hard)\n* Cluster 2: \"Easy Peasy Lemon Squeezy\" (short & flat)\n* Cluster 3: \"The Sweet Spot\" (not too long, not too high)\n* Cluster 4: \"I Don't Care About My Knees Anyway\" (too long for my own good)\n\n::: {.cell}\n\n```{.r .cell-code}\nfviz_nbclust(hiking_dat_by_trail[, 4:5], kmeans, method = \"wss\") # finding optimal number of clusters\nk4 <- kmeans(hiking_dat_by_trail[, 4:5], centers = 4, nstart = 25) # calculating clusters\n\nfviz_cluster(k4, data = hiking_dat_by_trail)  +\n  scale_x_continuous(name = \"Scaled Total Distance (miles)\") +\n  scale_y_continuous(name = \"Scaled Total Elevation (ft)\") +\n  scale_color_viridis(option = \"cividis\", discrete = T) +\n  scale_fill_viridis(option = \"cividis\", discrete = T) +\n  theme_minimal()\n```\n:::\n\n![](cluster_analysis.png){fig-alt=\"Cluster analysis of hikes by elevation and distance showing four distinct clusters\"}\n\n## I don't particularly love long hikes\n\nMy average hike is 6.4 miles - and most of them are concentrated around that distance. This makes sense as I usually day hike and need to get back at a reasonable time. My shortest hike was 1.18 miles and my longest was 17.85 (the Enchantments...). In these 90 hikes, I hiked around 576 miles.\n\n::: {.cell}\n\n```{.r .cell-code}\nhiking_dat_by_trail %>% \n  ggplot(aes(x = tot_dist)) +\n  geom_histogram(fill = \"#00204c\") +\n  xlab(\"Trail Total Distance (miles)\") +\n  ylab(\"Count\") +\n  scale_fill_viridis(option = \"cividis\") +\n  theme_minimal() +\n  theme(legend.position = \"none\")\n```\n:::\n\n![Histogram of hike total distance](dist_histogram.png){fig-alt=\"Histogram of hike total distance skewed right\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nhiking_dat_by_trail %>% \n  mutate(cumdist = cumsum(tot_dist)) %>% \n  ggplot(aes(x = trail,\n             y = cumdist,\n             fill = cumdist)) +\n  geom_bar(stat = \"identity\") +\n  scale_fill_viridis(option = \"cividis\") +\n  theme_minimal() +\n  theme(legend.position = \"none\")\n```\n:::\n\n![Cumulative bar plot of distance](cum_dist.png){fig-alt=\"Cumulative bar plot of distance increasing from the left to the right colored by a gradient\"}\n\n## I don't dislike high elevation hikes though\n\nElevation on these hikes ranged from ~0 feet to 4580 feet gain. I averaged 1455.4 feet gain and have climbed 130,984 feet (~24 miles!).\n\n::: {.cell}\n\n```{.r .cell-code}\nhiking_dat_by_trail %>% \n  ggplot(aes(x = tot_elev_gain)) +\n  geom_histogram(fill = \"#00204c\") +\n  xlab(\"Trail Total Elevation (ft)\") +\n  ylab(\"Count\") +\n  scale_fill_viridis(option = \"cividis\") +\n  theme_minimal() +\n  theme(legend.position = \"none\")\n```\n:::\n\n![](elev_histogram.png){fig-alt=\"Histogram of hike total elevation skewed right\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nhiking_dat_by_trail %>% \n  mutate(cumelev = cumsum(tot_elev_gain)) %>% \n  ggplot(aes(x = trail,\n             y = cumelev,\n             fill = cumelev)) +\n  geom_bar(stat = \"identity\") +\n  scale_fill_viridis(option = \"cividis\") +\n  theme_minimal() +\n  theme(legend.position = \"none\")\n```\n:::\n\n![](cum_elev.png){fig-alt=\"Cumulative bar plot of elevation increasing from left to right and colored by a gradient\"}\n\n<center>\n*Liked this article? I’d love for you to retweet!*\n\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">New blog post 🎉: Taking A Peek into My Hiking Data accessing Google Maps API with `googleway` ⛰️🗺 <a href=\"https://t.co/2foOUgPKIy\">https://t.co/2foOUgPKIy</a> <a href=\"https://twitter.com/hashtag/rstats?src=hash&amp;ref_src=twsrc%5Etfw\">#rstats</a> <a href=\"https://t.co/pEevVI9uxN\">pic.twitter.com/pEevVI9uxN</a></p>&mdash; Isabella Velásquez (@ivelasq3) <a href=\"https://twitter.com/ivelasq3/status/1125384610894843905?ref_src=twsrc%5Etfw\">May 6, 2019</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script> \n</center>",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": [],
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}